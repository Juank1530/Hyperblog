Vengo del futuro (del final de las clases)
aca dejo los apuntes para el que le interee, igual concentrate en practicarlos todos a medida que vayas viendo las clases, porfavor no te agobies por la cantidad, es mas facil de lo que parece, igual que todo, poco a poco te vas a ir puliendo‚Ä¶

git init ( sirve para indicar la carpeta ‚Äúpreviamente selecccionada‚Äù en la que se creara un repositorio en el disco duro o staggng)

git add ‚Äúe.g. Archivo.txt‚Äù (sirve para agregar un archivo especifico al area de stagging)

git add . (sirve para agregar todos los archivos al area de stagging)

git commit -m ‚Äúmensaje‚Äù (sirve para enviar todos los archivos del area de stagging al area del repositorio o ‚Äúmaster‚Äù)

git branch -M main

git show ( me muestra los cambios que han sido realizados a traves de las versiones)

git log ( me muestra las versiones que han sido guardadas en ‚ÄúMaster‚Äù)

git checkout ( me permite devolver en el tiempo un archivo a una version anterior sin borrar la actual o simplemente toda la carpeta
para que me muestre la version anterior en un archivo en especifico debo indicar al final el nombre del archivo)

git diff (indicandole las versions que queremos, nos muestra las diferencias entre ellas)

git reset xxxxxxxxxxxxxxxxxxxxxx --hard (este devuelve en el tiempo el projecto y elimina todo lo realizado posteriormente a la version a la que estamos volviendo)

git reset xxxxxxxxxxxxxxxxxxxxxx ‚Äì soft (este elimina los archivos del commit pero mantiene los archivos del area de stagging)

git reset xxxxxxxxxxxxxxxxxxxxxx head ( sirve para pasar los archivos de staging a unstaged en caso de que queramos editar algun archivo o lanzar en otra actualizacion
algun cambio que no era para este commit sino para un commit futuro)

git rm --cached: (Elimina los archivos del √°rea de Staging y del pr√≥ximo commit pero los mantiene en nuestro disco duro.)

git rm --force: (Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos,
de modo que podremos recuperarlos si es necesario
(pero debemos usar comandos m√°s avanzados).)

git clone url (sirve para clonar el proyecto de un repositorio ubicado en un servidor a mi repositorio y directorio de trabajo)

git push (sirve para enviar todos los datos actualizados en mi repositorio al repositorio del servidor.)

git fetch (importa un archivo que alguien mas cambio recientemente y no tienes en tu repositorio local, puedes usar git merge para combinar tus archivos,
en el directorio de trabajo con tu repositorio local para que quede unidos los cambios )

git merge (combina dos versiones)

git pull (a diferencia de fetch y merge al mismo tiempo, esta lo que hace es tomar los archivos,
actualizados del repositorio remoto y copiarlos tanto en mi repositorio local como en
mi directorio de trabajo, para asi tener una version actualizada del repositorio remoto.)

git commit -a (sirve para agregar directamente a master sin pasar por el staging)

git branch (sirve para ver las ramas creadas o sirve para crear una rama dependiendo de su uso, si usas el comando tal cual lo leiste,
solo te mostrara las ramas existentes, pero si lo usas de este modo e.g. (git branch "inserte aca nombre que le quiera proporcionar a la rama"
obviamente sin las comillas, crearas una rama nueva con el nombre que quieras.)

git commit -am (sirve para agregar al repositorio local los archivos que estas trackeando con un mensaje)

git remote add ‚Äúorigin‚Äù ( sirve para enviar el projecto en el que estamos trabajando a la base de datos o repositorio remoto)

git remote ( nos mostrara el repositorio remoto dispobible o existente)

git remote -v (nos indicara la direccion web del repositorio remoto)

git push ‚Äúorigin‚Äù ‚Äúmaster‚Äù

git pull ‚Äúorigin‚Äù ‚Äúmaster‚Äù

git pull ‚Äúorigin‚Äù ‚Äúmaster‚Äù --allow-unrelated-histories ( sirve para forzar a combinar los archivos del repositoerio remoto con el repositorio local)

git config -l ( nos muestra las configuraciones de git)

gir config global --user.email "jdbshfjbhfdsbjfh@gmail.com"

git log --all

git log --all --graph --decorate --oneline" ( me muestra todos los commits realizados en el proyecto de manera que se pueden observar los mensajes y los merges)

alias arbolito=‚Äúgit log --all --graph --decorate --oneline‚Äù (crear un alias, ese es el ejemplo, un alias ya sabes para que funciona)

git tag (me muestra las versionas realizadas es decir los tags

git tag -a v0.1 -m ‚ÄúResultado de las primeras clases del curso‚Äù 5d10f9c (ejempplo de como se hacen los tag)

git show-ref --tags ( me muestra los tags con las versiones y a que commit estan relacionados.)

git push origin --tags ( enviar los tags)

git tag -d ‚ÄúNombreDeTag‚Äù (me permite eliminar un tag que le indique)

git push origin :refs/tags/dormido ( codigo para eliminar el tag de github)

git show-branch (nos muestra todas las ramas, y si le agregamos --all nos muestra mas datos)

gitk (abre en un software la historia del proyecto, de una manera ultravisual)

git remote add ‚Äúupstream‚Äù (nos crea otrwa fuente nueva de donde podemos traer datos a nuestras rama amster)

git remote -v

git clone ‚Äúlink‚Äù (nos permite clonar un projecto publico)

cuando queremos que git ignore algun archivo, debemos crear un new file en el editor y guardarlo en el directorio
como ‚Äú.gitignore‚Äù luego en el editos utilizaremos ‚Äú*‚Äù para indicarle la extension de los archivos que queramos que
ignore

git rebase ( sirve para el momento de realizar un hotfix y que no se vea en el log de ramas el error)

git branch -D ‚Äúrama Name‚Äù (elimina una rama)

git stash (me devuelve el proyecto al estado anterior antes de ralizar algun cambio, manteniendo el cambio guardado temporalmente, es como presionar cntrl+z en Vs code)

git stash pop ( me devuelve al proyecto luego de hacer los cambios antes de aplicar el stash)

git stash list ( me muestra una lista de los stash)

git stash branch ‚Äúbranch name‚Äù (lo que hace es que si existe un stash, esto lo mueve a esa nueva rama, realizas un commit y queda gurdado el trabajo alli)

git stash drop ( sirve para borrar los stash realizados)

git clean (sirve para borrar archivos no deseados, o que no utilizas realmente en tu repositorio, agregando ‚Äú‚Äìdry-run‚Äù muestra todo lo que va a borrar el comando
pero si agregamos -f borra todo el listado que te muestra el comando anterior sin preguntar

git cherry-pick (sirve para traer un commit de otro rama a la que te encuentres(ES MALA PRACTICA))

git reflog (aun habiendo eliminado los errores con un git reset --hard, este muestra el log de los errores cometidos, aquellos que no
se ven en un ‚Äúgit log‚Äù)

git grep (busca en el proyecto las palabras usadas, el nombre de un archivo o lo que sea que le mandes a buscar, y si agregas ‚Äú-n‚Äù te dice inclusive
en que lineas se utiliza‚Ä¶ si utilizamos ‚Äú-c‚Äù nos indica las veces que utilizamos esas palabras)

git log -S ‚Äúpalabra a buscar‚Äù (busca la palabra que estas buscando en el historial o commits)

git blame ‚Äúnombre del archivo‚Äù (sirve para ver los commits realizados por las diferentes personas en orden con todos los datos si agregamos ‚Äú-c‚Äù se ve un poco mejor)

si utilizamos

git blame ‚Äúnombre del archivo‚Äù ‚Äú-L35,53‚Äù (nos muestra los cambios realizados por las personas en entre las lineas especificadas.)

comandos y recursos colaborativos en git y github

git shortlog ( me muestra el nombre de las personas colaborando y los commits realizados por cada una de ellas.)

git shortlog -sn (me muestra los nombres y la cantidad en numeros de los commits que hicieron)

git shortlog -sn --all (muestra inclusive los commits borrados)

git shortlog -sn -all --no-merges (lo mismo que el anterior pero omite contar los merges)

git congfig --global alias.(nombre del comando) ‚Äúgit shortlog -sn -all --no-merges‚Äù

git branch -r (te permite ver las ramas remotas en tu servidor)

git branch - a (te muestra las ramas locales y las remotas)

agrego el amend aca porque es un proceso por pasos:

para que sirve: cuaqndo realizas un commit pero en el commit olvidaste realizar una parte del trabajo o arreglar un detalle.

1ro. debes hacer tu cambio y verificar que colocaste el codigo bien y todo lo demas en tu editor de codigo como normalmente lo haces.

2do. vas a realizar un git add ‚Äúaqui vas a indicar el archivo que tiene los cambios que no colocaste‚Äù.

3ro. luego de agregar los archivos a staging vas a realizar un git commit --amend (esto agrega el archivo al que le hiciste los cambios al commi anterior.)

y listo, problema resuelto üòÑ

Keygen ssh creaton proceedements

code:

ssh-keygen -t rsa -b 4096 -C "parapapapaaaaaaa@gmail.com" (para crear el security shell debes introducir el codigo ssh-keygen donde "-t"
nos indicara la complejidad del algoritmo que vamos a utilizar en este caso ‚Äúrsa"
y -b nos indicara la complejidad de la llave en este caso usaremos ‚Äú4096‚Äù y por ultimo
-C es donde indicaremos el correo a usar "correo@gmail.com‚Äù

eval $(ssh-agent -s) (sirve para verificar si el cifrador de llaves esta funcionando en el sistema operativo, es igual en linux y en windows.)

para efectos de un mejor entendimiento se explicaran los siguientes signos a explicar en cada comando;

‚Äú‚Äù: la utilizacion de comillas indicara que luego del comando debe ir un nombre que indicara la creacion o el cambio de un archivo hacia otro, de una rama hacia otra
del envio del projecto al repositorio remoto.
Md= mark down
para que el repositorio se vea como pagina principal hay que escribir por eejempllo en mi caso

;Espancake.github.io

el git rebase solo debe hacerse en repositorios locales, no debe hacerce e repositorios remotos, es muy mala practica.

agregar --help al comando nos abre el manual del mismo.

Notas destacadas del curso:

windows y mac tienenn un standard de tildes distinto es un problema de unicode o de utf -8

se puede solucionar mediante el siguiente meta charset ;

<head>
<metacharset=‚ÄúUTF-8‚Äù />
‚Ä¶
</head>
********************************************************************
public keys

Generar una nueva llave SSH: (Cualquier sistema operativo)

ssh-keygen -t rsa -b 4096 -C "youremail@example.com"

Comprobar proceso y agregarlo (Windows)

eval $(ssh-agent - s)
ssh-add ~/.ssh/id_rsa
Comprobar proceso y agregarlo (Mac)

eval "$(ssh-agent -s)"
¬øUsas macOS Sierra 10.12.2 o superior?
Haz lo siguiente:

cd ~/.ssh
Crea un archivo config‚Ä¶
Con Vim vim config
Con VSCode code config
Pega la siguiente configuraci√≥n en el archivo‚Ä¶
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile ~/.ssh/id_rsa
Agrega tu llave

ssh-add -K ~/.ssh/id_rsa
ü•≥
--------------------------------------
SSH o Secure Shell: Es un protocolo de red que permite acceso remoto seguro a trav√©s de una conexi√≥n encriptada. Este m√©todo de autenticaci√≥n requiere un passphrase (contrase√±a) o tambien puede funcionar sin passphrase sobre la clave.
.
En el directorio Home ~

$ git config -l: Muestra la configuraci√≥n dentro de Git(user y email), Este comando funciona por que Git esta instalado en todo el equipo local.
.
$ git config --global user.email ‚Äúnombre_email_cambiado‚Äù : Se puede utilizar este mismo comando para cambiar el email.
.
Creamos la llave SSH

$ ssh-keygen -t rsa -b 4096 -C "tu_email@gmail.com"
-t = Especifica cual es el algoritmo que vamos a usar para crear esa llave.
rsa = Algoritmo a usar, hasta el momento el mas popular.
-b = Especifica que tan compleja es la llave.
4096 = Complejidad de la llave desde una perspectiva matem√°tica.
-C = Indica a que correo electr√≥nico va estar conectado esta llave
"tu_email@gmail.com" = Correo electr√≥nico.
.
Dato: Guardar la llave en la direcci√≥n predeterminada.
Dato2: Passphrase: Password con espacios o Contrase√±a adicional de texto que le vas a poner a tu llave p√∫blica y privada.
.
1er Paso:
Una ves que tengamos la llave, tenemos que agregarlo al entorno, y el entorno es b√°sicamente que el sistema operativo donde tu trabajas sepa que la llave existe. Para ello ejecutamos lo sgte:
.
revisar el servidor de llaves / Eval√∫a que un comando se dispare.

$ eval $(ssh-agent -s)
Dato: Agent pid 4724

Agent = Significa que el servidor de SHH esta corriendo.
pid = Process id o identificador del proceso.
4724 = N√∫mero que al sistema operativo le dice que el proceso esta corriendo.
.
2do Paso:

Agregamos la llave privada a nuestro sistema o al servidor por que no basta con que la llave solo exista, sino debemos decirle que existe. Para ello ejecutamos el siguiente comando:

$ ssh-add ~/.ssh/id_rsa
~ = Home
.ssh = carpeta ssh
id_rsa = llave privada la que nunca debemos de mostrar.
*************************************************************


Forks o Bifurcaciones
Es una caracter√≠stica √∫nica de GitHub en la que se crea una copia exacta del estado actual de un repositorio directamente en GitHub, √©ste repositorio podr√° servir como otro origen y se podr√° clonar (como cualquier otro repositorio), en pocas palabras, lo podremos utilizar como un git cualquiera
.
Un fork es como una bifurcaci√≥n del repositorio completo, tiene una historia en com√∫n, pero de repente se bifurca y pueden variar los cambios, ya que ambos proyectos podr√°n ser modificados en paralelo y para estar al d√≠a un colaborador tendr√° que estar actualizando su fork con la informaci√≥n del original.
.
Al hacer un fork de un poryecto en GitHub, te conviertes en due√±@ del repositorio fork, puedes trabajar en √©ste con todos los permisos, pero es un repositorio completamente diferente que el original, teniendo alguna historia en com√∫n.
.
Los forks son importantes porque es la manera en la que funciona el open source, ya que, una persona puede no ser colaborador de un proyecto, pero puede contribu√≠r al mismo, haciendo mejor software que pueda ser utilizado por cualquiera.
.
Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite al colaborador hacer pull request desde su repositorio propio.

Trabajando con m√°s de 1 repositorio remoto
Cuando trabajas en un proyecto que existe en diferentes repositorios remotos (normalmente a causa de un fork) es muy probable que desees poder trabajar con ambos repositorios, para √©sto puedes crear un remoto adicional desde consola.

git remote add <nombre_del_remoto> <url_del_remoto> 
git remote upstream https://github.com/freddier/hyperblog
Al crear un remoto adicional podremos, hacer pull desde el nuevo origen (en caso de tener permisos podremos hacer fetch y push)

git pull <remoto> <rama>
git pull upstream master
√âste pull nos traer√° los cambios del remoto, por lo que se estar√° al d√≠a en el proyecto, el flujo de trabajo cambia, en adelante se estar√° trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request.

git pull upstream master
git push origin master
*********************************************************************************

Consejos para readme.md

Despu√©s de mucho indagar pude dise√±ar una plantilla efectiva que uso en todos mis repositorios. Por ejemplo, mi repositorio m√°s votado es https://github.com/ManuelGil/Reset-Windows-Update-Tool y cumple con los siguientes consejos:

Usa emblemas (badges) que informen a otros desarrolladores sobre el estado de tu desarrollo (actualizaci√≥n, versi√≥n, licencia). Puedes encontrar o crear badges en https://shields.io/.
Puedes colocar atajos (follow, fork, issue, download) en tu repositorio que inviten a la acci√≥n. Aqu√≠ algunos atajos https://buttons.github.io/.
Los repositorios m√°s votados son aquellos que tienen un manual de contribuci√≥n y un c√≥digo de conducta. Ejemplos en ingl√©s: CONTRIBUTING.md - CODE_OF_CONDUCT.md.
Puedes agregar emojis en tu archivo README y en tus commits. Algunos truco para los mensajes en tus commits.
Como √∫ltima recomendaci√≥n, puedes hacer un archivo README en ingl√©s para que tu repositorios lleguen a un p√∫blico mucho mayor.

Espero que estos consejos te sean √∫tiles üòâ

*************************************************************

Stashed:
El stashed nos sirve para guardar cambios para despu√©s, Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de rama sin perder el trabajo que todav√≠a no guardamos en un commit

√âsto es especialmente √∫til porque hay veces que no se permite cambiar de rama, √©sto porque porque tenemos cambios sin guardar, no siempre es un cambio lo suficientemente bueno como para hacer un commit, pero no queremos perder ese c√≥digo en el que estuvimos trabajando.

El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, m√°s adelante, retomar el trabajo con los archivos que ten√≠amos en Staging pero que podemos recuperar ya que los guardamos en el Stash.

git stash
El comando git stash guarda el trabajo actual del Staging en una lista dise√±ada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.

Para agregar los cambios al stash se utiliza el comando:

git stash
Podemos poner un mensaje en el stash, para asi diferenciarlos en git stash list por si tenemos varios elementos en el stash. √âsto con:

git stash save "mensaje identificador del elemento del stashed"
Obtener elelmentos del stash
El stashed se comporta como una Stack de datos comport√°ndose de manera tipo LIFO (del ingl√©s Last In, First Out, ¬´√∫ltimo en entrar, primero en salir¬ª), as√≠ podemos acceder al m√©todo pop.

El m√©todo pop recuperar√° y sacar√° de la lista el √∫ltimo estado del stashed y lo insertar√° en el staging area, por lo que es importante saber en qu√© branch te encuentras para poder recuperarlo, ya que el stash ser√° agn√≥stico a la rama o estado en el que te encuentres, siempre recuperar√° los cambios que hiciste en el lugar que lo llamas.

Para recuperar los √∫ltimos cambios desde el stash a tu staging area utiliza el comando:

git stash pop
Para aplicar los cambios de un stash espec√≠fico y eliminarlo del stash:

git stash pop stash@{<num_stash>}
Para retomar los cambios de una posici√≥n espec√≠fica del Stash puedes utilizar el comando:

git stash apply stash@{<num_stash>}
Donde el <num_stash> lo obtienes desden el git stash list

Listado de elementos en el stash
Para ver la lista de cambios guardados en Stash y as√≠ poder recuperarlos o hacer algo con ellos podemos utilizar el comando:

git stash list
Retomar los cambios de una posici√≥n espec√≠fica del Stash || Aplica los cambios de un stash espec√≠fico

Crear una rama con el stash
Para crear una rama y aplicar el stash mas reciente podemos utilizar el comando

git stash branch <nombre_de_la_rama>
Si deseas crear una rama y aplicar un stash espec√≠fico (obtenido desde git stash list) puedes utilizar el comando:

git stash branch nombre_de_rama stash@{<num_stash>}
Al utilizar estos comandos crear√°s una rama con el nombre <nombre_de_la_rama>, te pasar√°s a ella y tendr√°s el stash especificado en tu staging area.

Eliminar elementos del stash
Para eliminar los cambios m√°s recientes dentro del stash (el elemento 0), podemos utilizar el comando:

git stash drop
Pero si en cambio conoces el √≠ndice del stash que quieres borrar (mediante git stash list) puedes utilizar el comando:

git stash drop stash@{<num_stash>}
Donde el <num_stash> es el √≠ndice del cambio guardado.

Si en cambio deseas eliminar todos los elementos del stash, puedes utilizar:

git stash clear
Consideraciones:

El cambio m√°s reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomar√° los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intenci√≥n de que git tenga un seguimiento de ese archivo, o tambi√©n utilizando el comando git stash -u (que guardar√° en el stash los archivos que no est√©n en el staging).
Al aplicar un stash este no se elimina, es buena pr√°ctica eliminarlo.


**************************************************************************

Cherry Pick
Este comando permite coger uno o varios commits de otra rama sin tener que hacer un merge completo. As√≠, gracias a cherry-pick, podr√≠amos aplicar los commits relacionados con nuestra funcionalidad de Facebook en nuestra rama master sin necesidad de hacer un merge.

Para demostrar c√≥mo utilizar git cherry-pick, supongamos que tenemos un repositorio con el siguiente estado de rama:

a - b - c - d   Master
         \
           e - f - g Feature
El uso de git cherry-pick es sencillo y se puede ejecutar de la siguiente manera:

git checkout master
En este ejemplo, commitSha es una referencia de confirmaci√≥n. Puedes encontrar una referencia de confirmaci√≥n utilizando el comando git log. En este caso, imaginemos que queremos utilizar la confirmaci√≥n ‚Äòf‚Äô en la rama master. Para ello, primero debemos asegurarnos de que estamos trabajando con esa rama master.

git cherry-pick f
Una vez ejecutado, el historial de Git se ver√° as√≠:

a - b - c - d - f   Master
         \
           e - f - g Feature
La confirmaci√≥n f se ha sido introducido con √©xito en la rama de funcionalidad

*******************************************************************************************

Git nunca olvida, git reflog
Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que est√°s haciendo s√≥lo es actualizar la punta del branch, para gestionar √©stas puntas existe un mecanismo llamado registros de referencia o reflogs.
.
La gesti√≥n de estos cambios es mediante los hash‚Äôes de referencia (o ref) que son apuntadores a los commits.
.
Los recoges registran cu√°ndo se actualizaron las referencias de Git en el repositorio local (s√≥lo en el local), por lo que si deseas ver c√≥mo has modificado la historia puedes utilizar el comando:

git reflog
Muchos comandos de Git aceptan un par√°metro para especificar una referencia o ‚Äúref‚Äù, que es un puntero a una confirmaci√≥n sobre todo los comandos:

git checkout Puedes moverte sin realizar ning√∫n cambio al commit exacto de la ref

git checkout eff544f
git reset: Har√° que el √∫ltimo commit sea el pasado por la ref, usar este comando s√≥lo si sabes exactamente qu√© est√°s haciendo

git reset --hard eff544f # Perder√° todo lo que se encuentra en staging y en el Working directory y se mover√° el head al commit eff544f
git reset --soft eff544f # Te recuperar√° todos los cambios que tengas diferentes al commit eff544f, los agregar√° al staging area y mover√° el head al commit eff544f
git merge: Puedes hacer merge de un commit en espec√≠fico, funciona igual que con una branch, pero te hace el merge del estado espec√≠fico del commit mandado

git checkout master
git merge eff544f # Fusionar√° en un nuevo commit la historia de master con el momento espec√≠fico en el que vive eff544f

*************************************************************************************************************************

Buscar cosas en el repositorio 

git grep color -->use la palabra color
git grep la --> donde use la palabra la
git grep -n color‚Äì> en que lineas use la palabra color
git grep -n platzi --> en que lineas use la palabra platzi
git grep -c la --> cuantas veces use la palabra la
git grep -c paltzi --> cuantas veces use la palabra platzi
git grep -c ‚Äú<p>‚Äù‚Äì> cuantas veces use la etiqueta <p>

git log-S ‚Äúcabecera‚Äù --> cuantas veces use la palabra cabecera en
todos los commits.

grep‚Äì> para los archivos
log --> para los commits.

*******************************************************************************

Comandos colaborativos 

git shortlog -sn = muestra cuantos commit han hecho cada miembros del equipo.
git shortlog -sn --all = muestra cuantos commit han hecho cada miembros del equipo hasta los que han sido eliminado
git shortlog -sn --all --no-merge = muestra cuantos commit han hecho cada miembros quitando los eliminados sin los merges
git blame ARCHIVO = muestra quien hizo cada cosa linea por linea
git COMANDO --help = muestra como funciona el comando.
git blame ARCHIVO -Llinea_inicial,linea_final= muestra quien hizo cada cosa linea por linea indic√°ndole desde que linea ver ejemplo -L35,50
**git branch -r **= se muestran todas las ramas remotas
git branch -a = se muestran todas las ramas tanto locales como remotas

crear comandos globales 

ejemplo 

git config --global alias.stats "git shortlog -sn --all --no-merge"